#version 430

vec3 interpolation(vec3 p1, vec3 p2, int v1, int v2)
{
	float f1 = float(v1) / 1000.0;
	float f2 = float(v2) / 1000.0;

	vec3 p;
	float isolevel = 0.0;
	
	if (abs(isolevel - f1) < 0.00001f)
		return p1;
	
	if (abs(isolevel - f2) < 0.00001f)
		return p2;
	
	if (abs(f1 - f2) < 0.00001f)
		return p1;
	
	float mu = (isolevel - f1) / (f2 - f1);

	p.x = p1.x + float(mu) * (p2.x - p1.x);
	p.y = p1.y + float(mu) * (p2.y - p1.y);
	p.z = p1.z + float(mu) * (p2.z - p1.z);
	return p;
}

layout (local_size_x = 1) in;

layout(std430, binding = 4) buffer inBuffer
{
	int distances[]; // 65 * 65 * 65
};

layout(std430, packed, binding = 5) buffer histoPyramid
{
	int verticesPerCell[];
};

layout(std140, binding = 6) buffer tables
{
	int edgeTable[256];
	int triTable[256 * 16];
	int vertCountTable[256];
};

void main()
{
	int xMax = 65;
	int yMax = 65;

	uint id = gl_GlobalInvocationID.x + (64 * gl_GlobalInvocationID.y) + (64 * 64 * gl_GlobalInvocationID.z);

	uint indices[8];
	indices[0] = 0 + id;
	indices[1] = 1 + id;
	indices[2] = 1 + id + xMax * yMax;
	indices[3] = 0 + id + xMax * yMax;
	indices[4] = 0 + id + xMax;
	indices[5] = 1 + id + xMax;
	indices[6] = 1 + id + xMax + xMax * yMax;
	indices[7] = 0 + id + xMax + xMax * yMax;

	uint marchingCubesCase =
	int(distances[indices[7]] < 0) << 7 |
	int(distances[indices[6]] < 0) << 6 |
	int(distances[indices[5]] < 0) << 5 |
	int(distances[indices[4]] < 0) << 4 |
	int(distances[indices[3]] < 0) << 3 |
	int(distances[indices[2]] < 0) << 2 |
	int(distances[indices[1]] < 0) << 1 |
	int(distances[indices[0]] < 0) << 0;
		
	verticesPerCell[id] = 0;

	if(marchingCubesCase != 0 && marchingCubesCase != 255)
	{
		//for (int j = 0; triTable[marchingCubesCase + j * 256] != -1; j += 3)
		{
			verticesPerCell[id] +=3;
		}	
	}

}