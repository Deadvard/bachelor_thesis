#version 430

vec3 interpolation(vec3 p1, vec3 p2, int v1, int v2)
{
	float f1 = float(v1) / 1000.0;
	float f2 = float(v2) / 1000.0;

	vec3 p;
	float isolevel = 0.0;
	
	if (abs(isolevel - f1) < 0.00001f)
		return p1;
	
	if (abs(isolevel - f2) < 0.00001f)
		return p2;
	
	if (abs(f1 - f2) < 0.00001f)
		return p1;
	
	float mu = (isolevel - f1) / (f2 - f1);

	p.x = p1.x + float(mu) * (p2.x - p1.x);
	p.y = p1.y + float(mu) * (p2.y - p1.y);
	p.z = p1.z + float(mu) * (p2.z - p1.z);
	return p;
}

layout (local_size_x = 8, local_size_y = 8, local_size_z = 8) in;

layout(std430, binding = 4) buffer inBuffer
{
	int distances[]; // 65 * 65 * 65
};

layout(std430, packed, binding = 5) buffer outBuffer
{
	int verticesPerCell[64 * 64 * 64];
};

layout(std140, binding = 6) buffer tables
{
	int edgeTable[256];
	int triTable[256 * 16];
};

void main()
{
	int xMax = 64;
	int yMax = 64;
	unsigned int id = gl_GlobalInvocationID.x + (xMax * gl_GlobalInvocationID.y) + (xMax * yMax * gl_GlobalInvocationID.z);
	
	unsigned int indices[8];
	indices[0] = 0 + id;
	indices[1] = 1 + id;
	indices[2] = 1 + id + xMax * yMax;
	indices[3] = 0 + id + xMax * yMax;
	indices[4] = 0 + id + xMax;
	indices[5] = 1 + id + xMax;
	indices[6] = 1 + id + xMax + xMax * yMax;
	indices[7] = 0 + id + xMax + xMax * yMax;

	unsigned int marchingCubesCase =
	int(distances[indices[7]] < 0) << 7 |
	int(distances[indices[6]] < 0) << 6 |
	int(distances[indices[5]] < 0) << 5 |
	int(distances[indices[4]] < 0) << 4 |
	int(distances[indices[3]] < 0) << 3 |
	int(distances[indices[2]] < 0) << 2 |
	int(distances[indices[1]] < 0) << 1 |
	int(distances[indices[0]] < 0) << 0;
	
	if(marchingCubesCase != 0 && marchingCubesCase != 255)
	{
		unsigned int x = id % xMax;
		unsigned int y = (id / xMax) % yMax;
		unsigned int z = id / (xMax * yMax);

		float voxelOffset = 0.1;

		float fx = float(x) * voxelOffset;
		float fy = float(y) * voxelOffset;
		float fz = float(z) * voxelOffset;

		vec3 positions[8];

		positions[0] = vec3(fx, fy, fz);
		positions[1] = vec3(fx + voxelOffset, fy, fz);
		positions[2] = vec3(fx + voxelOffset, fy, fz + voxelOffset);
		positions[3] = vec3(fx, fy, fz + voxelOffset);
							 
		positions[4] = vec3(fx, fy + voxelOffset, fz);
		positions[5] = vec3(fx + voxelOffset, fy + voxelOffset, fz);
		positions[6] = vec3(fx + voxelOffset, fy + voxelOffset, fz + voxelOffset);
		positions[7] = vec3(fx, fy + voxelOffset, fz + voxelOffset);

		vec3 vertices[12];

		if (bool(edgeTable[marchingCubesCase] & 1))
			vertices[0] = interpolation(positions[0], positions[1], distances[indices[0]], distances[indices[1]]);
		if (bool(edgeTable[marchingCubesCase] & 2))
			vertices[1] = interpolation(positions[1], positions[2], distances[indices[1]], distances[indices[2]]);
		if (bool(edgeTable[marchingCubesCase] & 4))
			vertices[2] = interpolation(positions[2], positions[3], distances[indices[2]], distances[indices[3]]);
		if (bool(edgeTable[marchingCubesCase] & 8))
			vertices[3] = interpolation(positions[3], positions[0], distances[indices[3]], distances[indices[0]]);
		if (bool(edgeTable[marchingCubesCase] & 16))
			vertices[4] = interpolation(positions[4], positions[5], distances[indices[4]], distances[indices[5]]);
		if (bool(edgeTable[marchingCubesCase] & 32))
			vertices[5] = interpolation(positions[5], positions[6], distances[indices[5]], distances[indices[6]]);
		if (bool(edgeTable[marchingCubesCase] & 64))
			vertices[6] = interpolation(positions[6], positions[7], distances[indices[6]], distances[indices[7]]);
		if (bool(edgeTable[marchingCubesCase] & 128))
			vertices[7] = interpolation(positions[7], positions[4], distances[indices[7]], distances[indices[4]]);
		if (bool(edgeTable[marchingCubesCase] & 256))
			vertices[8] = interpolation(positions[0], positions[4], distances[indices[0]], distances[indices[4]]);
		if (bool(edgeTable[marchingCubesCase] & 512))
			vertices[9] = interpolation(positions[1], positions[5], distances[indices[1]], distances[indices[5]]);
		if (bool(edgeTable[marchingCubesCase] & 1024))
			vertices[10] = interpolation(positions[2], positions[6], distances[indices[2]], distances[indices[6]]);
		if (bool(edgeTable[marchingCubesCase] & 2048))
			vertices[11] = interpolation(positions[3], positions[7], distances[indices[3]], distances[indices[7]]);

		int offset = 0;

		offset +=3;
		for (int j = 0; triTable[marchingCubesCase + j * 256] != -1; j += 3)
		{
			offset+=3;
		}
		verticesPerCell[id] = offset;
		
	}
}